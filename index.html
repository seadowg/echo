<html>
  <head>
    <title>echo</title>
    <link href="public/bootstrap.min.css" rel="stylesheet">
    <link href="public/master.css" rel="stylesheet">
  </head>
  <body>
    <div class="container">
      <div class="span9 offset1">
        <div class="title step">
          <h1>echo</h1>
            <h6>A Functional Reactive Programming framework for Scala</h6>
        </div>
      
        <div class="step">
          <h3>1. Get It</h3>
          <p>
            You can download the latest jar of the framework 
            <a href="http://github.com/downloads/oetzi/echo/echo.jar">here</a>. Just
            stick it in your project folder. I'd personally recommend <a href="http://buildr.apache.org/">buildr</a> 
            for building and compiling Scala projects. If you're wanting to hack on the source you can get that
            <a href="http://github.com/oetzi/echo">here</a>.
          </p>
        </div>
      
        <div class="step">
          <h3>2. FRP</h3>
          <p>
            Functional Reactive Programming is concerned with programming with two new types: Behaviours
            and Events. Behaviours are continuous values that change over time and Events are infinite
            streams of values that 'occur' at a discrete point in time - we can think of them as
            as a stream of time and value pairs. Mental eh?
          </p>
        
          <p>
            Lets see some examples. Here we're going to make a simple Behaviour:
          </p>
          <pre>
  val beh = Behaviour(time => time * 2)</pre>
        
          <p>
            This Behaviour will, at a given time <code>t</code> have the value <code>t * 2</code>. So how do we actually
            get at that value? We use the <code>eval</code> function:
          </p>
          
          <pre>
  val value = beh.eval()
  println(value)</pre>
  
          <p>
            The above code would evaluate the Behaviour at the current time and then print the calculated
            value out.
          </p>
          
          <p>
            So what about Events? Well here's something. Imagine we have an Event <code>mouseEv</code>
            that occurs every time the left mouse button is pressed. We could construct a Behaviour like this:
          </p>
          
          <pre>
  val false = Behaviour(time => false)
  val true = Behaviour(time => true)
  val beh = false.until(mouseEv, true)</pre>
  
          <p>
            This creates a Behaviour that has the value <code>false</code> until the left mouse button is
            pressed, at which point its value is <code>true</code>. Cool? How about this:
          </p>
          
          <pre>
  val beh = false.toggle(mouseEv, true)</pre>  
  
         <p>
           Guess what this does? Thats right. It produced a Behaviour that toggles between <code>false</code>
           and <code>true</code> whenever that crazy left mouse button is pressed.
         </p> 
         
         <p>
           Getting the hang of this? Lets jump in at the deep end:
          </p>
         
          <pre>
   val mouseTimes = mouseEv.map((t, v) => t)
   val lastTime = Stepper(-1, mouseTimes)</pre>
   
          <p>
            Ok. Here we map the mouse button Event to return a new Event who's values are that of the times
            of each occurrence. We then use a Stepper. A Stepper is a Behaviour that has an initial value
            and an Event: at any point in time its value will be the Event's last occurrence's value (or the initial
            value if the Event hasn't occurred). With all that put together you will see that we've created a Behaviour
            that's value will always be the last time the mouse button was pressed (or <code>-1</code> to specify it 
            was never pressed).
          </p>
          
          <p>
            That should all have hopefully got you into the right frame of mind. Lets move on to writing
            some code in echo...
          </p>
    
        </div>
        <div class="step">
          <h3>3. Writing Echo Code</h3>
          <p>
            To write echo applications you simply extend the <code>EchoApp</code> class with your
            code's main object. This class already has a defined <code>main</code> function
            that takes care of some stuff for you so all you need to do is write
            your code in the <code>setup</code> function like so:
          </p>
          
          <pre>
  object App extends EchoApp {
     def setup(args : Array[String]) {
       val beh = Behaviour(time => time * 2)
       val value = beh.eval()
       println(value)
     }
   }</pre>
   
          <p>
            Unfortunately in order to avoid the FRP semantics going bonkers you can only write echo code
            inside this <code>setup</code> function. This may seem restrictive but you'll find in FRP
            you generally write a small amount of code in an upfront declarative manner to define
            an entire applications run-time behaviour.
          </p>
          
          <p>
            There are a couple of cool things that we can do in echo.
            For instance, you might notice that a lot of the time we
            the Behaviours we create are 'constant'. So,
            we can express this easily we can just write constant 
            Behaviours as their static values:
          </p>
          <pre>
 val beh = 5.until(event, 5)</pre>     
        </div>
        
        <div class="step">
          <h3>4. Custom Events</h3> 
          
          <p>
            You are not restricted to only using the Events provided
            in echo. You can simply extend the EventSource class
            to create your own:
          </p>
          
          <pre>
  class CustomEvent extends EventSource[Int] {
    occur(5)
  }</pre>   
  
          <p>
            This creates an Event that when instantiated occurs
            with a value of <code>5</code>. The <code>occur</code>
            function used here is only available to classes that
            extends EventSource.
          </p>
        </div>
      
        <div class="step">
          <h3>5. Adding Graphics</h3>
          <p>
            There is also a simple UI framework in echo so you make funky GUI apps for your users.
            What's cool about this is that you can set GUI components attributes to be Behaviours
            Before we launch into all that though lets make a small little app with a button and
            some text:
          </p>
            
            <pre>
  val frame = Frame(200, 200, List(
    Text("Hello you!"),
    Button("Click Me!")
  ))</pre>
          </p>
          
          <p>
            This creates a Frame with a size of 200 x 200. It should be noted that these
            dimensions are Behaviours so if we set them to change over time the window
            size would stay up to date with the Behaviour's value. So lets do something with FRP:
          </p>
          
          <pre>
  val button = Button("Click Me!")
  val text = "Hello".until(button.click, "Goodbye")
  
  val frame = Frame(200, 200, List(
    text,
    button
  ))</pre>
  
          <p>
            When this app runs the text component will say "Hello" but when a user hits the button
            it will change to saying "Goodbye". You can see pretty immediately that this allows us
            to build our GUI's in a much nicer way. No ActionEventListener here. Its hard to cover
            all the different components and attributes for the UI framework here but the 
            <a href="docs">docs</a>
            should provide a good starting point.
          </p>
        </div>
      
        <div class="step">
          <h3>6. Over the Interwebs...</h3>
          <p>
            Lorem ipsum 
          </p>
        </div>
      </div>
    </div>
  </body>
</html>